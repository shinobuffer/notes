## 变量和类型

声明和定义是两个完全不一样的概念

- ==定义（定义声明）==：**指的是为对象分配内存空间**
- ==声明（引用声明）==：指的是引用已有对象，**不会分配内存空间**

通常来说，对象只能被定义一次，但可在多处声明

### 基本类型

基本类型包括==算术类型（整型、浮点）==和==空类型（void）==

整型/字符可以在类型说明符前添加 `unsigned` 关键字来限定无符号整型/字符。字面值可以添加 `U` 后缀来标识无符号，类似的后缀还有 `LL/F` 分别对应长整型和单精度浮点

| 整型类型                  | 含义         | 大小（字节）                  |
| ------------------------- | ------------ | ----------------------------- |
| short                     | 短整型       | 典型大小 2                    |
| int（整型字面值默认类型） | 整型         | `>=sizeof(short)`，典型大小 4 |
| long                      | 长整型       | `>=sizeof(int)`，典型大小 8   |
| long long                 | 长整型       | `>=sizeof(long)`，典型大小 8  |
| char                      | 字符         | 1                             |
| wchar_t                   | 宽字符       | 典型大小 4                    |
| char16_t                  | Unicode 字符 | 2                             |
| char32_t                  | Unicode 字符 | 4                             |
| bool                      | 布尔         | 1                             |

| 浮点类型                     | 含义         | 大小（字节） |
| ---------------------------- | ------------ | ------------ |
| float                        | 单精度浮点   | 4，有效位 7  |
| double（浮点字面值默认类型） | 双精度浮点   | 8，有效位 15 |
| long double                  | 扩展精度浮点 | --           |

> C++ 并未规定整型的精确大小，只要求整型的大小不能小于低一级的整型，所以可能会出现 `long long` 和 `long` 大小一样的情况，应该避免使用 `long`。如果想使用更更跨平台的类型，可以使用头文件 `<cstdint>` 中的类型
>
> 类型大小和类型转换的存在，会带来潜在的溢出的可能。建议开发者合理选择类型，**切勿混用无符号整型和有符号整型**

### 变量

在类型说明符后面接若干个逗号分隔的变量名来定义变量，定义变量的时候可同时执行初始化操作，没有初始化操作的变量将执行默认初始化，对应如下初始化方式

- ==拷贝初始化==：使用等号的初始化，等号右边的值会作为实参去匹配可用单参构造函数来构造对象
- ==直接初始化==：直接显式调用构造函数构造对象
- ==值初始化==：通过普通括号或大括号明确了初始化，但存在初始值的缺省，这些缺省初始值的变量将执行值初始化
  - 基础类型的值初始化，其值取决于类型本身，通常为 0
  - 类类型的值初始化，会调用其默认构造函数
- ==默认初始化==（局部、非静态变量）：只指明了类型，没有初始化操作时的兜底行为
  - 基础类型的默认初始化，会直接沿用被分配内存中的值，其值是未定义的
  - 类类型的默认初始化，会调用其默认构造函数

> 只要使用了括号但没有给出具体初始值，就是值初始化；没有使用括号，就是默认初始化。对于类类型，默认初始化和值初始化没有区别，都是调用其默认构造函数
>

```c++
// 拷贝初始化
int v1 = 1;
string s1 = "123";
// 直接初始化
int v2{2}; // 对于内置类型，大括号初始化的方式会检查类型转换时的信息丢失并报错
int v3(3);
// 值初始化
int v4(); // 值初始化为 0
int arr[3] = {1} // 数组第一个元素初始化为 1，其余元素值初始化为 0
// 默认初始化
int num, *pnum; // 值都是未定义的
int nums[3]; // 数组中的元素值未定义
```

**定义在文件顶层的变量将在==全局作用域==生效**，当前文件想要使用在其他文件定义的全局变量，需要进行 `extern` 声明表示该变量在其他地方被定义

```c++
// file1.cc
int share = 1;
// file2.cc
extern int share;
std::cout << share; // 1
```

变量的作用域遵循静态的词法作用域（以大括号为边界），变量查找从当前作用域向外层查找，内层作用域同名变量覆盖外层

> 在有名字覆盖的情况，可以通过作用域符号 `::` 来强制访问全局作用域

### 复合类型（左值引用、指针）

复合类型包括引用和指针，由声明符 `&/*` 指示

- 在变量名前加 `&` 声明符来定义==引用（左值）==，**引用定义时必须绑定到已有对象上（初始化）**；引用相当于对象的别名，操作引用其实就是操作引用绑定的值
- 在变量名前加 `*` 声明符来定义==指针==，指针是一种存储对象内存地址的对象，指向地址对应的对象
  - 通过 `*` 操作符解引用指针得到目标对象的引用
  - 当目标对象是类类型时，可通过 `->` 操作符直接访问目标对象的成员
  - 通过 `&` 操作符来取得对象的地址


```c++
std::string s("123");
std::string &rs = s; // 为引用绑定对象
rs = "234"; // 操作引用等价与操作引用绑定的值
std::cout << s; // 234

std::string *ps = &s; // 让指针指向对象
// 通过指针访问对象成员的两种等效方式
(*ps).size();
ps->size();
```

> **引用并不是对象，因此不能让指针指向引用；指针是对象，因此引用可以绑到指针上**
>
> ```c++
> // pref 是一个引用，绑定到了一个整型指针上
> int *&ref_ps = ps;
> ```
>
> **访问指针指向的对象时需确保指针确实指向某个存在的对象，建议定义指针时初始化指针**

### 枚举类型

枚举类型可以把一组相关的整型常量组织在一起，使用关键字 `enum` 来定义枚举类型。根据 `enum` 后是否有 `class/struct` 关键字，枚举类型可以是==限定作用域==或者==不限定作用域==的。限定作用域的枚举类型遵循常规作用域规则，内部枚举成员必须通过作用域符访问；不限定作用域的枚举类型，其内部枚举成员暴露到外层作用域，可直接访问

枚举成员的值默认从 0 开始依次递增，若中途指定了值则后续的枚举值则从该值开始依次递增。**枚举成员都是常量表达式**

```c++
// 不限定作用域的枚举类型，内部枚举成员暴露到外层作用域，可直接使用
// 枚举值默认从 0 开始，如果指定了值，则后续枚举值将从该指定值开始
enum status {no, yes};
std::cout << yes; // 1
// 限定作用域的枚举类型，枚举成员需通过 color:: 访问
enum class color {red = 3, green};
std::cout << color::green; // 4
```

> 非匿名枚举是一个独立的类型，虽然其成员值是整型，但除了不限定作用域的枚举类型成员可以转换为整型外，限定作用域的枚举类型和整型的相互转换是禁止的

### const/constexpr 限定符

`const` 限定符用于指示==常量（运行时常量）==，**常量必须初始化**

```c++
// num0 是一个常量，无法改变
const int num0 = 1；

// pnum1 是一个指向常量的指针，不能改变指针指向的值（指针本身不是常量）
const int *pnum1;
// pnum2 是一个常量指针，之后不能改变指针的指向（指针本身是常量，必须初始化）
int *const pnum2 = &num0;
// pnum3 是一个常量指针，并且指向常量，不能改变指针的指向也不能改变指针指向的值
const int *const pnum3 = &num0;
```

> 如何解读复杂类型的语句？谨记**「从括号内到括号外，从右到左，离变量名最近的声明符有最直接影响」**

`const` 有顶层和底层之分

- ==顶层 const== 指的是变量本身是常量，值无法改变
- ==底层 const== 只存在于指针/引用中，指向常量的指针和绑定常量的引用属于底层 `const`，无法改变其指向/绑定的值

> **底层 `const` 中，常量引用仅限制了引用的操作（只读），对绑定的对象本身是否是常量并无限制**，绑定的对象可以是常量的，也可以是非常量的（在这种情况下绑定的对象可能通过其他途径改变）；指向常量的指针同理，对指向的对象是否是常量并无限制
>
> **底层 `const` 的标识会成为类型的一部分左右着函数参数的匹配**（非常量类型可转换为常量类型，反过来不行）

`const` 常量默认只会在本文件可见，如果其他文件需要共享该常量，需要在定义时加上 `extern` 关键字，在其他文件使用时对该变量作出 `extern` 声明

```c++
// file1.cc
extern const int share = 1;
// file2.cc
extern const int share;
std::cout << share; // 1
```

`constexpr` 限定符用于指示==常量表达式（编译时常量）==，**其值必须在编译阶段计算出来**（通常来自字面值或 `constexpr` 变量/函数），否则编译器会报错

> `constexpr` 指针只能指向固定地址的对象，比如全局/静态对象；`constexpr` 引用同理

使用 `typedef/using` 关键字来定义类型别名

```c++
// 在变量定义语句前加上 typedef，变量名就会变成类型的别名
typedef int *pnum;
// p1 是整型指针
pnum p1;
// 类型别名的另一种定义方式
using pnum = int*;
```

### 类型推断

使用 `auto` 类型说明符定义并初始化变量来让编译器根据初始值自动推断变量的类型，**`auto` 定义会忽略掉顶层 `const` 和引用说明，如果需要定义常量或引用需重新加上 `const/&`**

使用 `decltype(exp)/decltype((exp))` 类型说明符可以获取表达式的求值类型，可配合 `typedef/using` 来定义类型别名。**双括号的版本会推断出引用类型；单括号版本只会在表达式是引用时才会推断出引用**

> `auto` 能根据初始值推断类型但是可能存在类型信息的丢失，`decltype` 可以完美的保留的类型信息，两者可结合起来得到一个==万能推导== `decltype(auto)`，使用该类型说明符可以实现完美的类型转发（类型是啥推断出来就是啥）


```c++
int num = 0, &rnum = num;
// v1 推断为 int
auto v1 = rnum;
// v2 推断为 int&
decltype(rnum) v2 = num;
// v3 推断为 int&
decltype((num)) v3 = num;

SomeClass& get_instance() {
  static SomeClass instance;
  return instance;
}
// instance 推断为 SomeClass&
decltype(auto) instance = get_instance();
// 等价的写法
decltype(get_instance()) instance = get_instance();
```

## 基础使用

C++ 的标准库在 `std` 命名空间下，使用相关函数库时需要引入相关头文件并在指定名字在命名空间中的位置

可以使用==using 声明==来引入某个名字或使用==using 指示==来引入命名空间中的所有名字，之后在使用名字的时候就无需指定完整的路径（为方便书写，之后代码默认已进行相关声明或指示，省略路径）

```c++
#include <iostream> // 输入输出所需头文件
#include <string> // string 所需头文件

// 使用 std 命名空间下的 string
std::string str = "string";
// 1. using 声明 std::out，之后可以直接使用 out
using std::cout;
cout << str;
// 2. using 指示 std，之后可以直接使用当前头文件下所有 std 下名字
using namespace std;
cin << cout;
```

### 字符串

标准库类型 `string` 表示可变长字符串，默认初始化为空字符串，其构造函数有如下形式：

- `string(strLike s)`，其中 `strLike` 可以是 `string/char[]`，以指定字符串为原本构造副本字符串
- `string(int repeat, char c)`，以指定字符重复指定次数构造字符串

```c++
// 拷贝初始化，以等号右边的值为原本构造对象
string s1 = "s1";
// 直接初始化，直接调用构造函数
string s2(s1);
string s3(3, 'c');
```

如需 IO 读写 `string`，可以使用如下方式

```c++
string str;
// 从输入流中读取字符串写入 str，遇到空白字符停止
cin >> str;
// 读取字符串写入 str，遇到换行符才会停止，并且丢弃该换行符
getline(cin, str);
```

`s.size()` 获取大小、`s.empty()` 判断是否为空；`string` 之间可以使用 `+` 进行拼接，或者使用比较运算符以字典序进行比较

> `s.size()` 返回一个 `string::size_type` 类型，这是一个无符号类型（容器类的特性），**注意不要和有符号数在表达式中混用**
>
> 字符串字面值其实是 `char[]`。因为 `string` 的构造函数是非 `explicit` 的，`string` 可以和字符串字面值相加，此时字符串字面值被包装转换为一个 `string` 再执行相加操作

可以通过范围 for 语句顺序访问 `string` 中的字符；也可以下标索引的形式随机访问字符（**需确保索引的位置不能越界**）。对于字符的处理，头文件 `<cctype>` 提供了许多便捷函数，如判断是否为字母 `isalpha(c)`、大小写转换 `tolower/toupper(c)` 等

```c++
string str("1234");
cout << str[1]; // 2
for (char c : str) cout << c; // 1234
// 这里的 c 是引用，可以通过 c 修改
for (char &c : str) c++; // str = 2345
```

字符串的另一种形式字符数组比较特别，字符数组的长度总是会比字符串的长度多 1，用于专门存储尾部的空字符。要处理字符数组，需要头文件 `<cstring>` 中的 C 风格函数，如 `strlen()` 获取字符串长度、`strcmp()` 比较字符串、`strcat()` 拼接字符串、`strcpy()` 拷贝字符串。如果可以的话，尽可能使用 `string` 而不是字符数组来表示字符串

### 向量

标准库类型 `vector` 表示向量（可变长数组），默认初始化为空向量，其构造函数有如下形式：

- `vector<T>(v)`，其中 `v` 是另外一个 `vector`，以指定向量为原本构造副本向量
- `vector<T>(int count, [T val])`，构造一个有 `count` 个元素，且每个元素都是 `val` 的向量（如不提供 `val`，则元素进行值初始化）
- `vector<T>(initializer_list<T> il)`，其中 `il` 是初始化列表（以大括号的形式表示），以初始化列表中元素为初始值构造向量

> `vector<T>` 是一个模板（类似于泛型），`T` 说明了向量中元素的类型

```c++
// 直接使用构造函数初始化，v1 长度为 10，每个元素都是 1
vector<int> v1(10, 1);
// 优先使用列表初始化，v2 长度为 2，元素分别为 10、1
vector<int> v2{10, 1};
// 无法执行列表初始化，匹配并执行第二种构造函数，v3 长度为 10，每个元素都是空字符串
vector<string> v3{10}
```

> 直接初始化中普通括号和大括号初始化的区别
>
> - **==普通括号初始化==会直接调用匹配的构造函数进行初始化**
>
> - **==大括号初始化==会优先尝试使用列表初始化，在无法执行时才会尝试使用匹配的构造函数进行初始化**

`vector` 和同为容器的 `string` 有着不少一致的用法，比如 `v.size()` 获取大小、`v.empty()` 判断是否为空；通过下标索引获取元素引用；使用比较运算符以字典序进行比较等

### 迭代器

所有容器都支持通过迭代器访问内部元素，容器可以通过其 `begin/cbegin()` 或 `end/cend()` 成员函数获取迭代器

- `begin()` 返回指向第一个元素的迭代器
- `end()` 返回指向==尾后元素==（最后元素的下一个位置，仅为标记，实际上不存在元素）的迭代器

> 当容器为空时 `begin() == end()` 都指向尾后元素
>
> 如果遍历过程中无需对元素进行写操作，应该使用 `cbegin/cend()` 获取常量版本的迭代器

迭代器支持的操作和数组指针基本一致，比如

- 通过 `*` 解引用获取元素的引用；通过 `->` 访问元素的成员
- 通过自增指向下一个元素，部分容器支持 `±n` 的方式获得指向前/后 n 个元素的迭代器
- 迭代器间可以作差来得到两个位置的距离
- 迭代器间可通过相等性比较来判断是否指向用一个位置

```c++
vector<int> v{1, 2, 3};
for (auto it = v.cbegin(); it !== v.cend(); ++i) cout << *it; // 1 2 3
```

> **和下标索引一样，使用迭代器需确保迭代器的指向不能越界**

### 数组

如果没有特殊说明，C++ 中的数组特指内置数组，使用类型说明符和中括号定义。**定义数组时需指定数组的维度和维度大小，或者通过初始化让编译器推断维度的大小（数组的维度和维度大小是类型的一部分，维度大小必须为 `constexpr` 常量表达式）。**允许通过范围 for 语句来遍历数组

```c++
// 定义一维字符串数组，长度为 3，第一个元素初始化为 "a"，其余元素值初始化为空字符串
string strs[3] = {"a"};
// 定义并初始化整型数组（推断为一维数组，长度为 3），元素分别为 1、2、3
int nums[] = {1, 2, 3};
for (auto item : nums) cout << item; // 123
```

> **数组不允许拷贝和赋值，但数组是对象允许被引用绑定**
>
> ```c++
>// 优先和中括号绑定，所以首先是一个长度为 3 的数组，元素类型为整型指针
> int *ptrs[3];
>// 优先和 & 绑定，所以首先是一个引用，绑定到上述数组
> int *(&ref)[3] = ptrs; 
> ```

**数组可以当作指向数组首元素的指针使用（数组作为参数传递时也会自动转换为指针）**。因为数组是一块连续的空间，指向数组元素的指针在不越界的前提下可以使用指针的运算操作，支持 ±n 的方式获得指向前/后 n 个元素的指针，指针间也可以作差来得到两个位置的距离

```c++
int nums[] = {1, 2, 3};
// 指针 p 指向 nums 的第一个元素，等价于 int *p = &nums[0];
int *p = nums;
// 访问第二个元素的两种等价方式 arr[n] === *(arr + 1)
cout << nums[1];
cout << *(nums + 1);
```

> **在数组上使用下标索引/指针，需确保指向不能越界**
>
> 可以使用头文件 `<iterator>` 提供的 `begin/end(arr)` 方便的获取数组的头元素指针和尾后元素指针，避免手动计算带来的越界风险
>

**多维数组指的是元素为数组的数组**，而数组等价于数组首元素的指针，因此范围 for 遍历多维数组时，需要将非最内层遍历元素声明为引用类型，避免被转换为指针导致无法遍历

```c++
// 遍历二维数组
int matrix[2][3] = {{1, 2, 3}, {4, 5, 6}};
for (auto const &row : matrix) // 这样 row 的类型就会为 (&int)[] 而不是 int *p，可以被遍历
  for (auto const &item : row)
    cout << item;
```

## 表达式

> 常用优先级：`.` = `[]` > 前置递增减 > 后置递增减 = `*` = `&` > 算术运算符 > 移位 > 关系运算符 > 赋值运算符

大多数运算符都没有规定运算对象的求值顺序，因此**要避免在赋值操作中使用某个值的同时修改某个值**

```c++
string s("abc");
for (auto &c :s) c = c++; // 错误用法，因为求值顺序不确定，可能先求左边，也可能先求右边
```

`sizeof` 运算符用于获取类型/表达式结果所占空间的大小（字节数），如果对数组求值将返回数组所占大小，即「元素数量 * 每个元素所占空间大小」

> `sizeof` 在编译阶段求值，其返回值为 `constexpr` 常量表达式

### 类型转换

==隐式类型转换==会尽可能避免信息的丢失，是编译器自动执行的，包括如下情况

- 算术运算/关系运算中，运算对象的类型会转换为同一类型（提升至其中最高级的类型）
- 条件中，非布尔值会转换为布尔值
- 初始化过程中，初始值类型会转换为变量的类型；赋值过程中，等号右边的类型会转换为等号左边的类型
- 函数调用中，实参类型会转换为形参的类型，`return` 的类型会转换为返回值类型

==显式类型转换==指通过代码执行强制类型转换

- `static_cast<T>(e)` 用于强制类型转换（忽略信息丢失的警告），但需要注意如下两种无法处理的情况
  - `static_cast` 无法去除 `e` 的类型中的底层 `const`，应该使用 `const_cast`
  - `static_cast` 不进行运行时类型检查，因此类的下行转换（基类转换为派生类）是不安全的，应该使用 `dynamic_cast`

- `const_cast<T>(e)` 用于去除 `e` 的类型中的底层 `const`
- `dynamic_cast<T>(e)` 用于将基类的指针/引用 `e` 安全的转换为派生类的指针/引用，类型 `T` 必须为类类型的指针/引用（指针转换失败返回 0，引用转换失败抛出 `bad_cast` 异常）

> 应该优化代码设计来避免使用强制类型转换

## 函数

一个最基础的函数定义由返回类型、函数名、形参列表和函数体构成，形如 `T fun_name(T1 t1, T2 t2) {}`。函数的声明则是在函数定义的基础上省略函数体并以分号结尾（函数声明的形参列表可以省略形参名）。**调用函数要求函数的声明可见**

> **函数定义本身就是声明**
>
> **数组/函数不能被拷贝，因此函数的返回类型不能是数组/函数，但可以是指向数组/函数的指针或引用**

函数内部的普通局部变量对象（非静态、非动态分配内存）会在退出函数时被自动销毁，如果需要某个变量对象的生命周期贯穿多次函数调用，可以加上 `static` 限定符将其声明为==局部静态对象==。局部静态对象仅在函数第一次调用时初始化，退出函数后也不会被销毁

```c++
void fun() {
  // 普通局部对象
	int count = 0;
	// 局部静态对象
	static int static_count = 0;
	count++;
	static_count++;
	cout << count << "," << static_count; // count 永远是 1，但是 static_count 会随着函数调用递增
}
```

**在声明/定义函数时，可以为函数指定默认实参（默认实参需位于参数序列的尾部）**，调用函数时可省略该实参

```c++
void print(vector<string> lines[], char separator = '\n');
```

### inline/constexpr/static 函数

通常情况下，函数是不能被重复定义的，一个编译单元中出现多个有相同签名的函数定义，或者链接时两边发现有相同签名的函数定义，编译器无法做出选择而报二义性错误。将函数标记为 `inline`，可以允许该函数被重复定义（不参与到签名的比较中），编译器最后会保留其中的一个定义作为实现

将函数标记为 `constexpr`，表示该函数的调用可以在编译阶段求值，**`constexpr` 函数隐式是 `inline` 的**。`constexpr` 函数体有且仅有一条 `return` 语句，其实参必须为常量表达式

> `inline/constexpr` 函数虽然允许重复定义，但最终编译器会随机保留一个作为实现，这种随机性会反过来限制开发者保证这多个定义都是一样的。**因此 `inline/constexpr` 函数应该定义在头文件中**
>
> `inline/constexpr` 关键字加在函数定义的返回值类型之前

标记为 `static` 的函数仅在当前编译单元可见，因此不存在重复定义的问题

### 参数传递

函数的参数传递有两种形式，取决于形参的类型

- ==值传递==：非引用类型的形参（包括指针类型），实参将拷贝一份副本赋值给形参（可能存在隐式类型转换）
- ==引用传递==：引用类型的形参，实参将被绑定到形参上，改变形参的同时也会改变实参

> 对于非基础类型的形参，最好声明成引用来避免拷贝，如果没有修改形参的需要则将形参声明为常量引用

数组不能被拷贝，在值传递的过程中，实际上会作为一个对应的指针拷贝赋值给形参。另外也可以把数组形参声明为引用类型，走引用传递的过程

```c++
// 注意：下面的声明实际上违反了函数重载规则，这里只是为了展示不同的声明方式
// 一维数组非引用形参声明的两种等价方式
void print(const int *arr);
void print(const int arr[]);
// 如果是多维数组，后续维度需要指定大小
void print(const int (*arr)[10]);
void print(const int arr[][10]);

// 数组引用形参声明方式
void print(const int (&arr)[10]);
```

> 使用数组形参的函数通常会使用额外的参数来标记数组的大小/边界

对于数量不确定的形参，可以使用 `initializer_list<T>` 初始化列表类型来表示同类型形参的序列，向 `initializer_list` 形参传递参数时需要把参数序列用大括号包裹起来

- 和 `vector` 一样的是，`initializer_list` 提供了 `begin/end()` 成员函数供遍历元素
- 和 `vector` 不一样的是，`initializer_list` 中的元素永远是常量值

```c++
void print(initializer_list<string> il) {
  for (auto p = il.begin(); p != il.end(); ++p) cout << *p << " ";
}
print({"Do", "You"}); // Do You
```

### 返回值传递

返回值根据其类型也存在值传递和引用传递两种方式

- ==值传递==：非引用类型的返回值，`return` 结果将拷贝一份副本作为返回值（可能存在隐式类型转换）

- ==引用传递==：引用类型的返回值，`return` 结果将绑定到返回值

> 函数不能返回普通局部对象的指针/引用，因为普通局部对象会在退出函数后被销毁

如果要声明一个返回数组指针的函数，其声明会比较复杂，看上去不是很直观。对于这类返回类型比较复杂的函数，可以将其返回类型后置提升可读性（在原返回类型的位置用 `auto` 说明类型符替代，并且在参数列表后面用 `->` 指示真正的返回类型），称为==尾置返回类型==

```c++
// fun 是一个函数，接收一个整型参数 i，返回值是一个指针，指向一个长度为 10 的数组，数组元素的类型为整型
int (*fun(int i))[10]; // 参数列表先于返回值指向数组的维度

// 尾置返回类型
auto fun(int i) -> int (*)[10];
```

### 函数重载与函数匹配

函数重载允许定义多个同名但形参列表不同的函数，在调用函数时编译器会根据实参从候选函数中选择最佳匹配作为最终调用对象

> **有效的函数重载需要在形参序列的类型（忽略顶层 `const`）或数量上存在差异**
>
> 名字查找发生在类型检查之前，如果当前作用域存在和外层作用域重载函数重名的对象，这些外层重载函数将全部被隐藏

当实参数量（包括默认参数）和形参数量相等，且所有实参都能精确匹配/隐式转换为形参时，称该函数是可行的。只有一个可行函数，则该函数为最佳匹配。如果存在多个可行函数，则逐个检查实参，有且只有一个函数满足以下条件，则该函数为最佳匹配；否则存在多个最佳匹配，编译器无法做出选择而报二义性错误

- 每个实参的匹配都不劣于其他可行函数的匹配
- 至少有一个实参的匹配优于其他可行函数的匹配

参数匹配的优劣等级从优到劣的等级如下

1. 精确匹配（类型相同，或者数组/函数转换为对应的指针）
2. `const` 转换匹配
3. 类型提升匹配
4. 算术转换匹配、指针转换匹配
5. 类类型转换匹配

### 函数指针

定义一个指向函数的指针，只需在函数声明的基础上替换函数名即可。**函数本身可以当作指向函数的指针使用，而正确指向的函数指针也可以当成函数直接调用**。若存在函数重载，函数指针初始化时编译器会根据函数指针的类型将最佳匹配的函数分配给指针

```c++
// 函数声明
int compare(const string &, const string &);
// 对应函数指针定义
int (*pfun1)(const string &, const string &) = compare;
// 直接使用函数或者对函数取地址是等价的
int (*pfun2)(const string &, const string &) = &compare;

// 正确指向的函数指针的以当成函数直接调用
pfun1("222", "333");
// 函数指针取址后再调用是等价的
(*pfun1)("222", "333");
```

函数类型的形参与对应函数指针类型的形参等价，参数传递时函数会隐式的转换为指针

```c++
// 函数类型的形参的两种声明方式
void fun(int pfun(const string &, const string &));
void fun(int (*pfun)(const string &, const string &));
```

> 对于比较复杂的函数指针返回类型，建议配合类型别名/尾置返回类型
