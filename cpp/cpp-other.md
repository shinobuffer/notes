### 正则表达式

标准库头文件 [`<regex>`](https://www.apiref.com/cpp-zh/cpp/regex.html) 提供正则支持。`regex` 类型用于表示一个正则表达式，其构造函数 `regex(str, [f])` 接受一个表示正则表达式的字符串 `str` 和可选标记 `f`。`regex` 对象可以使用成员函数 `r.assign(str, [f])` 或者赋值号重置正则表达式

> `regex` 对象的构造和赋值操作会触发正则表达式的编译，若表达式非法将抛异常

`regex_match(args)` 函数用于判断目标序列是否与给定正则表达式匹配；`regex_search(args)` 函数用于在目标序列中查找与给定正则表达式匹配的第一个子序列，返回布尔表示是否存在。`args` 可以是如下参数组合中的一种

- `seq, r`，在序列 `seq` 中使用正则表达式 `r` 匹配
- `seq, m, r`，在序列 `seq` 中使用正则表达式 `r` 匹配，并把匹配结果写入匹配对象 `m`

若想在序列中查找所有与给定正则表达式匹配的子序列，可以使用==正则迭代器 Xregex_iterator== （前缀 `X` 取决于序列的类型），正则迭代器类似于插入迭代器，重载了迭代器上的操作，解引用迭代器得到当前匹配对象，递增迭代器将前往下一个匹配。**正则迭代器的默认构造函数返回一个尾后迭代器，用于判断匹配结束**

```c++
regex r("\\d{4}"); // 匹配连续四个数字
string str("1234-5-6789");
sregex_iterator it(str.begin(), str.end(), r), end_it;
// 未到尾后迭代器，说明匹配还未完成
while(it != end_it) {
	cout << it->str(); // 调用当前匹配对象的 str 成员，返回当前匹配的子序列
	it++; // 前往下一个匹配
}
```

==匹配对象 Xmatch==用于表示正则的匹配结果，成员函数 `m.str/prefix/suffix()` 分别获取当前匹配的子序列/子序列之前的部分/子序列之后的部分。当正则表达式包含子表达式时，匹配对象会包含多个==子匹配对象 Xsub_match==，可通过匹配对象上的如下操作来访问子匹配对象：

- `m[n]`，获取第 `n` 个子表达式对应的子匹配对象引用（`n` 从 0 开始，当 `n` 为 0 时表示完整匹配，下同）
- `m.str(n)`，获取第 `n` 个子表达式匹配的序列
- `m.position(n)`，获取第 `n` 个子表达式出现的位置
- `m.begin/end()`，用于遍历子匹配对象

子匹配对象用于表示子表达式的匹配结果，`sm.matched` 指示了该子表达式是否匹配了序列，如果存在匹配可进一步使用 `sm.str()` 来获取匹配的子序列，或者 `sm.first/second` 表示匹配子序列范围的迭代器

`regex_replace(seq, r, fmt, mtf)` 函数将序列中匹配正则的部分替换为指定字符串 `fmt`（替换字符串中可以使用 `$n` 来引用第 `n` 个子表达式匹配的序列），并返回替换后的结果

### 随机数

标准库头文件 [`<random>`](https://www.apiref.com/cpp-zh/cpp/numeric/random.html) 提供随机数支持，生成一个随机数需要==随机数引擎==和==随机数分布==配合完成。**随机数引擎负责生成一定范围内的随机整型，随机数分布使用随机数引擎作为随机源，生成指定范围内服从特定概率分布的随机数**

不同的随机数引擎使用不同的实现来产生随机数，如 `random_device` 利用硬件特性来产生真随机数，而 `mt19937` 利用梅森旋转算法产生伪随机数。其中 `random_device` 性能较低，通常不作为随机源使用，而是用于生成种子供伪随机数引擎初始化使用。**一个引擎对象是一个可调用对象，直接调用生成一个随机数**，其成员方法 `e.seed(s)` 可以重置种子，`e.discard(n)` 可以推进 n 步

最常用的分布是均匀分布 `uniform_int_distribution/uniform_real_distribution<T>`，初始化时指定随机数的生成范围，用于生成指定范围内均匀分布的整型/浮点随机数，更多的分布还有二项分布、泊松分布等。**分布对象也是一个可调用对象，调用时接受一个引擎对象，返回一个随机数**

> 伪随机源是的随机数是计算产生的，是可推导的，同一初始状态的同一类型的两个随机源，他们的前 n 次输出必定相等，因此**伪随机源通常使用真随机种子初始化并且以单例的形式被使用**

```c++
// 真随机源，由硬件支持
random_device rd;
// 使用梅森旋转算法的伪随机源，使用一个真随机数作为初始种子
mt19937 e(rd());

// 两个均匀分布，分别生成 [1,10] 整型和 [0, 1] 实数
uniform_int_distribution<int> int_dis(1, 10);
uniform_real_distribution<double> real_dis(0, 1);

// 使用随机源调用分布对象获得随机数
cout << int_dis(e) << endl << real_dis(e);
```

### 异常处理

使用 `try-catch` 语句来捕获和处理异常，`catch` 的形参类型决定了当前 `catch` 子句能处理什么类型的异常（要求异常类型能转换为捕获类型），形参类型可以是引用/非引用，对应引用传递/值传递

一个 `try-catch` 块可以有多条 `catch` 子句，多条 `catch` 子句按照其顺序进行匹配，因此越具体的异常类型应该越靠前。**形参为省略号 `...` 的 `catch` 子句可以处理任何类型的异常，通常放在最后用于兜底**

当异常发生时，异常之后的语句不再执行，并且开始沿着函数调用链向上寻找最近匹配的 `catch` 子句，向上寻找的过程中若退出函数则销毁函数的局部变量（调用对象的析构函数），若直至顶层也没有匹配的 `catch` 子句，则整个程序终止，这个过程称为==栈展开==

> 若函数块内涉及直接管理的动态内存，应该确保异常发生时也能正常的释放已经分配的内存（利用函数内 `try-catch` 或类对象的析构函数）
>
> 析构函数在栈展开的过程中被自动调用，因此析构函数不应该抛异常

异常除了内部抛出，还可以使用 `throw` 语句来手动抛出一个异常（异常类型没有限制）；`catch` 子句中若遇到不能处理的异常，可通过空 `throw` 语句重新抛出当前的异常，重新触发栈展开，交由上层处理

```c++
try {
  // if-need throw
	throw runtime_error("some error");
} catch (runtime_error e) { // 处理 runtime_error 类型异常（值传递）
  cout << e.what(); // some error
  throw; // 重新抛出异常，交由上层处理
} catch (...) { // 处理所有异常
	// ...
}
```

类构造的过程中有可能会出现异常，可能会出现在初始值列表中，也有可能出现在函数体中，若想处理初始值列表中出现的异常，需要把 `try` 关键字提前至初始值列表之前，`catch` 关键字延后至函数体之后，成为==函数 try 语句块==

```c++
A::A(int n) try : share(make_shared<int>(n)) {
  // 函数体
} catch(const bad_aloc &e) {
  // 处理可能的内存分配异常
} 
```

函数可以通过在参数列表后面追加 `noexcept` 关键字来做出==无异常承诺==，编译器和标准库对有无异常承诺的函数存在特殊的优化操作。`noexcept` 关键字也可以选择性接受一个布尔实参表示是否不会抛出异常

`noexcept` 同时也是运算符，`noexcept(exp)` 返回一个布尔表示指定表达式 `exp` 是否会抛出异常

> 若虚函数做出无异常承诺，派生类中的虚函数也必须维持无异常承诺

```c++
void fun_noexcept() noexcept; // 不会抛异常，等价于 void fun_noexcept() noexcept(true)
void fun_except(); // 有可能抛异常，等价于 void fun_noexcept() noexcept(false)
void fun() noexcept(noexcept(fun_noexcept())); // 和 fun_noexcept 函数一样不会抛异常
```
